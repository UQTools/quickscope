from pathlib import Path
from typing import Dict, Mapping
from shutil import rmtree
from flask import Response

from quickscope.server import app


SUCCESS = Response(status=200)
FAILURE = Response(status=500)


def make_session(session_id: str) -> Path:
    """
    Creates a session directory with the given session_id if it does not already exist.

    :param session_id: the session ID generated by the React front-end whenever the page is loaded
        or reloaded.
    :return: the path object corresponding to the session_id, which now must exist.
    """
    session_path = Path(app.config["UPLOAD_FOLDER"]).joinpath(session_id)
    if not session_path.exists():
        session_path.mkdir(parents=True, exist_ok=True)
    return session_path


def deep_update(original: Dict, updates: Mapping) -> Dict:
    """
    Update a nested dictionary with new values, leaving unupdated values in place.
    Modifies original in place.

    :param original: the dictionary whose values will be updated
    :param updates: the dictionary with the values to you want to insert into original
    """
    for key, value in updates.items():
        if isinstance(value, Mapping) and value:
            returned = deep_update(original.get(key, {}), value)
            original[key] = returned
        else:
            original[key] = updates[key]
    return original


def collapse_path_overlap(clean_file: str, component: str, locations: Dict[str, str]) -> str:
    """
    Removes the risk of creating duplicated folders in the state directory by checking if the
    clean_file has any directory overlap with the component location e.g. /solutions/correct/
    and correct/a1.py would ensure that a1.py was put in /solutions/correct/a1.py and not
    /solutions/correct/correct/a1.py.

    :param clean_file: the uploaded file cleaned of any leading forward slashes
    :param component: the particular component being uploaded
    :param locations: the set of upload locations specific to the engine associated with the
        session
    :return: the collapsed path as a string
    """
    folders = locations[component].split("/")
    if clean_file.startswith(locations[component]):
        return ""
    elif clean_file.startswith("/".join(folders[1:])):
        return folders[0]
    elif clean_file.startswith("/".join(folders[2:])):
        return "/".join(folders[:1])
    else:
        return locations[component]


def reconstruct(session_id: str, component: str, files, locations: Dict[str, str]) -> None:
    """
    Finds the appropriate directory for uploaded file(s) and saves them there.

    :param session_id: the session ID provided by the React front end
    :param component: the type of component being uploaded (e.g. linter config file)
    :param files: the files from the Flask request
    :param locations: the locations associated with the components that make up the engine selection
    """
    session_path = make_session(session_id)

    if component == "linter_config":
        file_name = None

        for file_name_ in files:
            file_name = file_name_

        file_path = session_path.joinpath("checkstyle.xml")
        file_path.unlink(missing_ok=True)

        if file_name:
            file = files.get(file_name)
            file.save(file_path)

        return

    if component == "visible":
        file_name = None

        for file_name_ in files:
            file_name = file_name_

        file_path = session_path.joinpath(locations.get("visible")).joinpath("visible_tests.txt")
        file_path.unlink(missing_ok=True)

        if file_name:
            file_path.parent.mkdir(parents=True, exist_ok=True)
            file = files.get(file_name)
            file.save(file_path)

        return

    if component == "formatter":
        file_name = None

        for file_name_ in files:
            file_name = file_name_

        file_path = session_path.joinpath(locations.get("formatter")).joinpath("formatter.py")
        file_path.unlink(missing_ok=True)

        if file_name:
            file_path.parent.mkdir(parents=True, exist_ok=True)
            file = files.get(file_name)
            file.save(file_path)

        return

    subdirectory = session_path.joinpath(locations[component])

    if subdirectory.exists():
        rmtree(session_path.joinpath(locations[component]))
    for file in files:
        clean_file = file[1:] if file.startswith('/') else file
        component_folder = collapse_path_overlap(clean_file, component, locations)
        parent_directory = session_path.joinpath(component_folder)\
            .joinpath(Path(clean_file).parent)
        file_path = parent_directory.joinpath(Path(file).name)

        if not parent_directory.exists():
            parent_directory.mkdir(parents=True, exist_ok=True)
        if file_path.exists():
            file_path.unlink(missing_ok=True)
        files.get(file).save(file_path)
